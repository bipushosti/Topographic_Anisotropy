


import numpy as np
from numba import *
from numbapro import *
import math
from math import pi
from itertools import izip
from operator import itemgetter
import scipy.io 
import math
import pdb





#****************************************Function Definitions*********************
#Function to get dx and dy components
#Type 0=dx 1=dy

#@vectorize(['float32(float32,float32,float32,int64)'],target = 'gpu')
#def get_dx_dy(Var,rad,IndexedAngle,Type):
	

#	if(Type == 0):
#		VarRad = math.cos(IndexedAngle)*rad
#	else:
#		VarRad = math.sin(IndexedAngle)*rad

#	dVarAdd = (Var + VarRad)
#	return dVarAdd




@vectorize(['float32(float32,float32,float32,float32,float32,float32)'],target = 'gpu')
def get_dx_dy(VarX,VarY,rad,varArrayX,varArrayY,angle):
	
	VarRadx = math.cos(angle)*rad
	VarRady = math.sin(angle)*rad
	
	dVarx = (VarX + VarRadx) - varArrayX
	dVary = (VarY + VarRady) - varArrayY
	dist = (dVarx**2 + dVary**2)**0.5
#	cuda.syncthreads()	
	return dist



@cuda.jit(argtypes=[f4[:],f4[:],f4[:,:],f4[:],f4[:]])
def get_dist_jit(ArrScalar,angle,dist,varArrayX,varArrayY):

	VarX = ArrScalar[0] 
	VarY = ArrScalar[1]
	rad = ArrScalar[2]
	
	i, j = cuda.grid(2)
	
	if (i < dist.shape[1]) and (j < dist.shape[0]):
		
		VarRadx = cuda.shared.array(shape=(len(angle),),dtype=float32)
		VarRady = cuda.shared.array(shape=(len(angle),),dtype=float32)
		dVarx = cuda.shared.array(shape=dist.shape,dtype=float32)
		dVary = cuda.shared.array(shape=dist.shape,dtype=float32)

		VarRadx[j] = math.cos(angle[j])*rad
		VarRady[j] = math.sin(angle[j])*rad

		cuda.syncthreads()

		dVarx[j,i] = ( VarX + VarRadx[j] * rad ) - varArrayX[i]
		dVary[j,i] = ( VarY + VarRady[j] * rad ) - varArrayY[i]

		cuda.syncthreads()

		dist[j,i]= (dVarx[j,i]**2 + dVary[j,i]**2)**0.5

#	cuda.syncthreads()
		

#	index[i] = dist[i][:].index(min(dist[i]))


#Function to get the distance using dx and dy
@guvectorize(['void(float32[:],float32[:],float32[:])'],'(n),(m)->(m)',target='gpu')
def get_dist(dX,dY,dist):
	#dist = (dX**2 + dY**2)**0.5
#	for i in range(0,len(dX)):
#		dist[i] =(dX[i]*dX[i] + dY[i]*dY[i])**0.5
	dist[0] = (dX[0]*dX[0] + dY[0]*dY[0])**0.5

@guvectorize(['void(float32[:],float32[:])'],'(n)->()',target='gpu')
def get_row_mean(ValArray,OutArray):
	tmp = 0
	for i in range(ValArray.shape[0]):
		tmp+=ValArray[i]
	tmp = tmp/ValArray.shape[0]
	OutArray[0] = tmp


@vectorize(['float32(float32,float32)'],target='gpu')
def get_cor_bi(tempArr1,tempArr2):
	cor_bi= (tempArr1 + tempArr2)/2
	return cor_bi


@guvectorize(['void(float32[:],int64[:],float32[:])'],'(m),(n)->(n)',target='gpu')
def get_value2(LastCol,index,value2):

	for i in range(0,len(index)):
		if index[i] <=18:
			Tmpval2 = LastCol[index[i] + 18]
		else:
			Tmpval2 = LastCol[index[i] - 18]
		value2[i] = Tmpval2


#****************************Variables & Array Declarations**********************

#**Making sure the numpy arrays are float32

data = np.array([],dtype = np.float32)
xvalues = np.array([],dtype=np.float32)
yvalues = np.array([],dtype=np.float32)
zvalues = np.array([],dtype=np.float32)

#Should be int32
angle = np.array([],dtype=np.float32)
dx = np.array([],dtype=np.float32)
dy = np.array([],dtype=np.float32)
dist = np.array([],dtype=np.float32)
ind = np.array([],dtype=np.int32)

cor_bi = np.array([],dtype=np.float32)
cor = np.array([],dtype=np.float32)

semiminor = np.array([],dtype = np.float32)
tilt = np.array([],dtype = np.float32)
tmpArray = np.array([],dtype = np.float32)
aspect_ratio = np.array([],dtype = np.float32)
coords = np.array([],dtype = np.float32)

tvalx = np.array([],dtype=np.float32)
tvaly = np.array([],dtype=np.float32)

val1 = np.array([],dtype=np.float32)
val2 = np.array([],dtype=np.float32)
tmpVal2 = np.array([],dtype=np.float32)


l=0

window=0
radius=1800
radwindow=4000 
radstep=900 # measure correlation to radius advancing by radstep
angle = np.arange(0,356*pi/180,5*pi/180)[np.newaxis]#5 degree separation of spokes
angle = angle.T
angle = angle.astype(np.float32)
spoke  = np.zeros((72,1)) # initialize spoke array

#**********************************************************************************
#Loading the .mat file and getting x,y,z data
mat = scipy.io.loadmat('numbers.mat')
data = mat['dat']
data = np.float32(data)

#Assign dimensions of study area, try to keep it small. Necessary for huge
# maps. Comment out otherwise.
#dat=fulldat
left=9.892e5
right=1.191e6
up=3.011e6
down=2.85e6

#Getting only the ones that are within the limits
data=data[data[:,0]>=left-radius,:]
data=data[data[:,0]<=right+radius,:]
data=data[data[:,1]>=down-radius,:]
data=data[data[:,1]<=up+radius,:]

#topo X coords
xvalues = data[:,0]
#topo Y coords
yvalues = data[:,1]
#topo Z coords rounded to an integer
zvalues = data[:,2]
#zvalues = zvalues.astype(int)

dataSize = len(xvalues)


xMin = np.amin(xvalues)
xMax = np.amax(xvalues)
yMin = np.amin(yvalues)
yMax = np.amax(yvalues)

if window == 1 :
	#cor has dimensions based on left, right, up, down
	#size of cor based on number of times we want to increase the scale
	#initialize raw correlogram matrix	
	cor = np.zeros((len(angle),radius/radstep-((radius-radwindow)/radstep)))
else:
	#initialize raw correlogram matrix FOR FULL AVERAGING
	cor = np.zeros((len(angle),radius/radstep)) 

cor_bi=np.zeros((len(angle)/2,radius/radstep))

#initialize mean normalized correlogram matrix
mean_norm_cor=cor

cor = np.float32(cor)
cor_bi = np.float32(cor_bi)


#*************************************************************
#			Array Assignments

dist = np.zeros(shape = (len(angle),len(xvalues)))
ind = np.zeros(len(angle))
aspect_ratio = np.zeros(shape = (dataSize,radius/radstep))
semiminor = np.zeros((1,radius/radstep))
tmpArray = np.zeros(shape = (1,radius/radstep))
tilt = np.zeros((dataSize,radius/radstep))
coords = np.zeros((dataSize,3))
val1 = np.zeros(radius/radstep)
val2 = np.zeros(radius/radstep)
tmpVal2 = np.zeros(radius/radstep)

ind.dtype = np.int32
rad = np.float32()
xx = np.float32()
yy = np.float32()
cc = np.float32()
tempCC = np.float32()
#**************************************************************

kk_prime=5
kk=0


#for k in range (0,dataSize/4):
#for k in range(0,dataSize):
for k in range(555,755):
	if (k/dataSize *100 >= kk):
	    print kk,"percent done\n"
	    kk=kk+kk_prime
	
	print k
	#Current values(single values)
	xx=data[k,0]
	yy=data[k,1]
	cc=data[k,2]


	if ((radius>(xx-xMin)) or 
	(radius>(yy-yMin)) or
	((radius+xx)>xMax) or 
	((radius+yy)>yMax)):		
		continue

	print "Hello\n"
	if window == 0 :
		# Step through radii
		for j in range(0,radius/radstep):
			# Advance radius length per iteration
			rad = radstep * (j+1)
			rad = np.float32(rad)
			#rad = np.float32(rad)
			#for i in range(0,len(angle)):			

			rad=(radius-radwindow)+radstep*(j+1)
			rad = np.float32(rad)
			ArrScalar = np.array([xx,yy,rad],dtype=np.float32)

			d_ArrScalar = cuda.to_device(ArrScalar)
			d_angle = cuda.to_device(angle)
			d_dist = cuda.to_device(dist)
			d_xvalues = cuda.to_device(xvalues)
			d_yvalues = cuda.to_device(yvalues)

			get_dist_jit[(41,72),(1024,1)](ArrScalar,d_angle,d_dist,d_xvalues,d_yvalues)
			
			#dist =  get_dist_jit(xx,yy,rad,angle,dist,varArrayX,varArrayY):
			#dist = get_dx_dy(xx,yy,rad,xvalues,yvalues,angle)		

			dist = d_dist.copy_to_host()

			ccJ = np.array([cc,j],dtype = np.float32)
			ind = dist.argmin(axis=1)
			cor[:,j] = ((cc-zvalues[ind])**2)*0.5

		if (j>0):
			cor[:,j] = get_row_mean(cor)
	else:
		# Step through radii
		for j in range(0,radius/radstep-((radius-radwindow)/radstep)):
			# Advance radius length per iteration
			rad=(radius-radwindow)+radstep*(j+1)
			rad = np.float32(rad)

			dx = np.zeros((len(angle),dataSize)) 		
			dx.dtype = np.float32
			
			dy = np.zeros((len(angle),dataSize))
			dy.dtype = np.float32

#		dist = get_dx_dy(xx,yy,rad,xvalues,yvalues,angle)
	
			ccJ = np.array([cc,j],dtype = np.float32)
			ind = dist.argmin(axis=1)
			cor[:,j] = ((cc-zvalues[ind])**2)*0.5

		if (j>0):
			cor[:,j] = get_row_mean(cor)


	tempArr1 = np.array(cor[0:36])	
	tempArr2 = np.array(cor[36:len(cor)])
	cor_bi = get_cor_bi(tempArr1,tempArr2)
	
	val1 = cor_bi.min(axis=0)
	ind1 = cor_bi.argmin(axis=0)

	cor_bi_LastCol = np.array(cor_bi[:,radius/radstep-1 ])
	print cor_bi_LastCol.shape
	val2 = get_value2(cor_bi_LastCol,ind1)
	#for i in range(0,len(ind1)):
	#	if ind1[i] <=18:
	#		val2 = np.append(val2,cor_bi[ind1[i]+18,radius/radstep - 1])
	#	else:
	#		val2 = np.append(val2,cor_bi[ind1[i]-18,radius/radstep -1])

	
	semimajor = radius
	semiminor = radius * val1/val2
	aspect_ratio[l,:] = 1 - ((semiminor**2)  / (semimajor*semimajor))**0.5
	
	for i in range (0,len(ind1)):
		indVal = ind1[i]
		degVal = math.degrees(angle[indVal])
		tmpArray.put(i,degVal)

	tilt[l,:] = tmpArray
	coords[l,:] = [xx,yy,cc]
	l = l + 1
	
#np.savetxt('aspect_ratio.txt',aspect_ratio)
#np.savetxt('tilt.txt',tilt)
#np.savetxt('coords.txt',coords)	

#print cor
				
